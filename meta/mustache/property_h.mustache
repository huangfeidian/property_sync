
#ifndef __meta_parse__
public:
friend class spiritsaway::property::prop_record_proxy<{{{class_name}}}>;
friend class spiritsaway::property::prop_replay_proxy<{{{class_name}}}>;
{{#has_base_class}}
using base_class = {{{base_class_name}}};
using base_class::base_class;
{{/has_base_class}}
{{^has_base_class}}
{{{class_name}}}();
{{/has_base_class}}

{{#property_fields}}

const decltype(m_{{field_name}})& {{field_name}}() const
{
	return m_{{field_name}};
}
{{/property_fields}}


public:

bool replay_mutate_msg(spiritsaway::property::property_replay_offset offset, spiritsaway::property::property_cmd cmd, const json& data);

bool operator==(const {{{class_name}}}& other) const;
bool operator!=(const {{{class_name}}}& other) const;

json encode_with_flag(const spiritsaway::property::property_flags flag, bool ignore_default, bool replace_key_by_index) const;
void encode_with_flag(const spiritsaway::property::property_flags flag, bool ignore_default, json::array_t& result) const;
void encode_with_flag(const spiritsaway::property::property_flags flag, bool ignore_default, json::object_t& result) const;

friend void swap({{{class_name}}}& a, {{{class_name}}}& b)
{
{{#has_base_class}}
	swap(({{{base_class_name}}}&)a, ({{{base_class_name}}}&)b);
{{/has_base_class}}

{{#property_fields}}	
	std::swap(a.m_{{field_name}}, b.m_{{field_name}});
{{/property_fields}}
}

void clear()
{
	*this = {{{class_name}}}();
}

json encode() const;

bool decode(const json& data);
bool decode(const json::object_t& data);
bool decode(const std::vector<std::pair<std::uint8_t, json>>& data, std::uint32_t& next_idx);

bool has_default_value() const;

protected:
{{#property_fields}}
constexpr static std::uint8_t index_for_{{field_name}} = {{field_index}};
constexpr static std::uint64_t flag_for_{{field_name}} = {{field_flags}};

{{/property_fields}}

constexpr static std::uint8_t index_begin_for_{{{class_name}}} = {{property_idx_begin}};
constexpr static std::uint8_t index_end_for_{{{class_name}}} = {{property_idx_max}};
private:

#endif


