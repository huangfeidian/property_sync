
#ifndef __meta_parse__

template <> 
class prop_record_proxy<spiritsaway::test::simple_vec_item>
	
{
	spiritsaway::test::simple_vec_item& m_simple_vec_item_data;
	item_msg_queue m_queue;
	const property_flags m_flag;
public:

public:
	prop_record_proxy(spiritsaway::test::simple_vec_item& data, msg_queue_base& msg_queue,
		const property_record_offset& offset, const property_flags& flag, std::uint32_t data_idx)
		: m_queue(msg_queue, offset, data_idx)
		, m_simple_vec_item_data(data)
		, m_flag(flag)
	{

	}
	

	




const spiritsaway::test::simple_vec_item& data() const
{
	return m_simple_vec_item_data;
}

	prop_record_proxy<decltype(m_simple_vec_item_data.m_a)> a()
	{
		property_record_offset empty_offset;
		return prop_record_proxy<decltype(m_simple_vec_item_data.m_a)>(m_simple_vec_item_data.m_a, m_queue, empty_offset.merge(spiritsaway::test::simple_vec_item::index_for_a), m_flag.merge(property_flags{ spiritsaway::test::simple_vec_item::flag_for_a}));
	}
	prop_record_proxy<decltype(m_simple_vec_item_data.m_b)> b()
	{
		property_record_offset empty_offset;
		return prop_record_proxy<decltype(m_simple_vec_item_data.m_b)>(m_simple_vec_item_data.m_b, m_queue, empty_offset.merge(spiritsaway::test::simple_vec_item::index_for_b), m_flag.merge(property_flags{ spiritsaway::test::simple_vec_item::flag_for_b}));
	}


};
#endif