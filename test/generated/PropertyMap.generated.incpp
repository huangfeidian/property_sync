
PropertyMap::PropertyMap()
	: m_a{}
	, m_b{}
	, m_c{}
	, m_d{}
	, m_e{}
	, m_f{}
	, m_g{}
{

}

bool PropertyMap::replay_mutate_msg(spiritsaway::property::property_offset offset, spiritsaway::property::property_cmd cmd, const json& data)
{
	auto split_result = offset.split();
	auto field_index = split_result.second;
	auto remain_offset = split_result.first;
	switch(field_index)
	{
		case index_for_a:
		{
			auto temp_proxy = make_replay_proxy(m_a);
			return temp_proxy.replay(remain_offset, cmd, data);
		}
		case index_for_b:
		{
			auto temp_proxy = make_replay_proxy(m_b);
			return temp_proxy.replay(remain_offset, cmd, data);
		}
		case index_for_c:
		{
			auto temp_proxy = make_replay_proxy(m_c);
			return temp_proxy.replay(remain_offset, cmd, data);
		}
		case index_for_d:
		{
			auto temp_proxy = make_replay_proxy(m_d);
			return temp_proxy.replay(remain_offset, cmd, data);
		}
		case index_for_e:
		{
			auto temp_proxy = make_replay_proxy(m_e);
			return temp_proxy.replay(remain_offset, cmd, data);
		}
		case index_for_f:
		{
			auto temp_proxy = make_replay_proxy(m_f);
			return temp_proxy.replay(remain_offset, cmd, data);
		}
		case index_for_g:
		{
			auto temp_proxy = make_replay_proxy(m_g);
			return temp_proxy.replay(remain_offset, cmd, data);
		}
		default:
		
			return false;
	}
}

bool PropertyMap::operator==(const PropertyMap& other) const
{
	
	if(m_a != other.m_a)
	{
		return false;
	}
	if(m_b != other.m_b)
	{
		return false;
	}
	if(m_c != other.m_c)
	{
		return false;
	}
	if(m_d != other.m_d)
	{
		return false;
	}
	if(m_e != other.m_e)
	{
		return false;
	}
	if(m_f != other.m_f)
	{
		return false;
	}
	if(m_g != other.m_g)
	{
		return false;
	}
	return true;
}
bool PropertyMap::operator!=(const PropertyMap& other) const
{
	return !(operator==(other));
}


json PropertyMap::encode() const
{
	
	json result;
	
	if(!spiritsaway::property::has_default_value<decltype(m_a)>()(m_a))
	{
		result["a"] = spiritsaway::serialize::encode(m_a);
	}
	
	if(!spiritsaway::property::has_default_value<decltype(m_b)>()(m_b))
	{
		result["b"] = spiritsaway::serialize::encode(m_b);
	}
	
	if(!spiritsaway::property::has_default_value<decltype(m_c)>()(m_c))
	{
		result["c"] = spiritsaway::serialize::encode(m_c);
	}
	
	if(!spiritsaway::property::has_default_value<decltype(m_d)>()(m_d))
	{
		result["d"] = spiritsaway::serialize::encode(m_d);
	}
	
	if(!spiritsaway::property::has_default_value<decltype(m_e)>()(m_e))
	{
		result["e"] = spiritsaway::serialize::encode(m_e);
	}
	
	if(!spiritsaway::property::has_default_value<decltype(m_f)>()(m_f))
	{
		result["f"] = spiritsaway::serialize::encode(m_f);
	}
	if(!m_g.has_default_value())
	{
		result["g"] = m_g.encode();
	}
	
	return result;
}
void PropertyMap::encode_with_flag(const spiritsaway::property::property_flags flag, bool ignore_default, json::array_t& result) const
{
	

	if((flag_for_a & flag.value) == flag.value)
	{
		
		if(!ignore_default ||!spiritsaway::property::has_default_value<decltype(m_a)>()(m_a))
		{
			result.push_back(spiritsaway::serialize::encode(std::make_pair(index_for_a, m_a)));
		}
	}
	if((flag_for_b & flag.value) == flag.value)
	{
		
		if(!ignore_default ||!spiritsaway::property::has_default_value<decltype(m_b)>()(m_b))
		{
			result.push_back(spiritsaway::serialize::encode(std::make_pair(index_for_b, m_b)));
		}
	}
	if((flag_for_c & flag.value) == flag.value)
	{
		
		if(!ignore_default ||!spiritsaway::property::has_default_value<decltype(m_c)>()(m_c))
		{
			result.push_back(spiritsaway::serialize::encode(std::make_pair(index_for_c, m_c)));
		}
	}
	if((flag_for_d & flag.value) == flag.value)
	{
		
		if(!ignore_default ||!spiritsaway::property::has_default_value<decltype(m_d)>()(m_d))
		{
			result.push_back(spiritsaway::serialize::encode(std::make_pair(index_for_d, m_d)));
		}
	}
	if((flag_for_e & flag.value) == flag.value)
	{
		
		if(!ignore_default ||!spiritsaway::property::has_default_value<decltype(m_e)>()(m_e))
		{
			result.push_back(spiritsaway::serialize::encode(std::make_pair(index_for_e, m_e)));
		}
	}
	if((flag_for_f & flag.value) == flag.value)
	{
		
		if(!ignore_default ||!spiritsaway::property::has_default_value<decltype(m_f)>()(m_f))
		{
			result.push_back(spiritsaway::serialize::encode(std::make_pair(index_for_f, m_f)));
		}
	}
	if((flag_for_g & flag.value) == flag.value)
	{
		if(!ignore_default || !m_g.has_default_value())
		{
			result.push_back(spiritsaway::serialize::encode(std::make_pair(index_for_g, m_g.encode_with_flag(flag, ignore_default, true))));
		}
		
	}
	return;
}

void PropertyMap::encode_with_flag(const spiritsaway::property::property_flags flag, bool ignore_default, json::object_t& result) const
{
	

	if((flag_for_a & flag.value) == flag.value)
	{
		
		if(!ignore_default ||!spiritsaway::property::has_default_value<decltype(m_a)>()(m_a))
		{
			result["a"] = spiritsaway::serialize::encode(m_a);
		}
	}
	if((flag_for_b & flag.value) == flag.value)
	{
		
		if(!ignore_default ||!spiritsaway::property::has_default_value<decltype(m_b)>()(m_b))
		{
			result["b"] = spiritsaway::serialize::encode(m_b);
		}
	}
	if((flag_for_c & flag.value) == flag.value)
	{
		
		if(!ignore_default ||!spiritsaway::property::has_default_value<decltype(m_c)>()(m_c))
		{
			result["c"] = spiritsaway::serialize::encode(m_c);
		}
	}
	if((flag_for_d & flag.value) == flag.value)
	{
		
		if(!ignore_default ||!spiritsaway::property::has_default_value<decltype(m_d)>()(m_d))
		{
			result["d"] = spiritsaway::serialize::encode(m_d);
		}
	}
	if((flag_for_e & flag.value) == flag.value)
	{
		
		if(!ignore_default ||!spiritsaway::property::has_default_value<decltype(m_e)>()(m_e))
		{
			result["e"] = spiritsaway::serialize::encode(m_e);
		}
	}
	if((flag_for_f & flag.value) == flag.value)
	{
		
		if(!ignore_default ||!spiritsaway::property::has_default_value<decltype(m_f)>()(m_f))
		{
			result["f"] = spiritsaway::serialize::encode(m_f);
		}
	}
	if((flag_for_g & flag.value) == flag.value)
	{
		if(!ignore_default || !m_g.has_default_value())
		{
			result["g"] = m_g.encode_with_flag(flag, ignore_default, false);
		}
		
	}
	return;
}
json PropertyMap::encode_with_flag(const spiritsaway::property::property_flags flag, bool ignore_default, bool replace_key_by_index) const
{
	if (replace_key_by_index)
	{
		json::array_t result;
		encode_with_flag(flag, ignore_default, result);
		return result;
	}
	else
	{
		json::object_t result;
		encode_with_flag(flag, ignore_default, result);
		return result;
	}
}

bool PropertyMap::decode(const std::vector<std::pair<std::uint8_t, json>>& data)
{
	
	for(const auto& one_item: data)
	{
		if(one_item.first >= index_end_for_PropertyMap)
		{
			continue;
		}
		if(one_item.first < index_begin_for_PropertyMap)
		{
			continue;
		}
		switch(one_item.first)
		{
			case index_for_a:
			{
				if(!spiritsaway::serialize::decode(one_item.second, m_a))
				{
					return false;
				}
				break;
			}
			case index_for_b:
			{
				if(!spiritsaway::serialize::decode(one_item.second, m_b))
				{
					return false;
				}
				break;
			}
			case index_for_c:
			{
				if(!spiritsaway::serialize::decode(one_item.second, m_c))
				{
					return false;
				}
				break;
			}
			case index_for_d:
			{
				if(!spiritsaway::serialize::decode(one_item.second, m_d))
				{
					return false;
				}
				break;
			}
			case index_for_e:
			{
				if(!spiritsaway::serialize::decode(one_item.second, m_e))
				{
					return false;
				}
				break;
			}
			case index_for_f:
			{
				if(!spiritsaway::serialize::decode(one_item.second, m_f))
				{
					return false;
				}
				break;
			}
			case index_for_g:
			{
				if(!spiritsaway::serialize::decode(one_item.second, m_g))
				{
					return false;
				}
				break;
			}
			default:
				return false;
		}
	}
	return true;
}

bool PropertyMap::decode(const json::object_t& data)
{
	
	decltype(data.end()) iter;
	iter = data.find("a");
	if(iter != data.end())
	{
		if(!spiritsaway::serialize::decode(iter->second, m_a))
		{
			return false;
		}
	}
	
	iter = data.find("b");
	if(iter != data.end())
	{
		if(!spiritsaway::serialize::decode(iter->second, m_b))
		{
			return false;
		}
	}
	
	iter = data.find("c");
	if(iter != data.end())
	{
		if(!spiritsaway::serialize::decode(iter->second, m_c))
		{
			return false;
		}
	}
	
	iter = data.find("d");
	if(iter != data.end())
	{
		if(!spiritsaway::serialize::decode(iter->second, m_d))
		{
			return false;
		}
	}
	
	iter = data.find("e");
	if(iter != data.end())
	{
		if(!spiritsaway::serialize::decode(iter->second, m_e))
		{
			return false;
		}
	}
	
	iter = data.find("f");
	if(iter != data.end())
	{
		if(!spiritsaway::serialize::decode(iter->second, m_f))
		{
			return false;
		}
	}
	
	iter = data.find("g");
	if(iter != data.end())
	{
		if(!spiritsaway::serialize::decode(iter->second, m_g))
		{
			return false;
		}
	}
	
	return true;
}

bool PropertyMap::decode(const json& data)
{
	if(data.is_object())
	{
		json::object_t obj_data = data.get<json::object_t>();
		return decode(obj_data);
	}
	else if(data.is_array())
	{
		std::vector<std::pair<std::uint8_t, json>> array_data;
		if(!spiritsaway::serialize::decode(data, array_data))
		{
			return false;
		}
		return decode(array_data);
	}
	return false;
	
}

bool PropertyMap::has_default_value() const
{
	
	
	if(!spiritsaway::property::has_default_value<decltype(m_a)>()(m_a))
	{
		return false;
	}
	
	if(!spiritsaway::property::has_default_value<decltype(m_b)>()(m_b))
	{
		return false;
	}
	
	if(!spiritsaway::property::has_default_value<decltype(m_c)>()(m_c))
	{
		return false;
	}
	
	if(!spiritsaway::property::has_default_value<decltype(m_d)>()(m_d))
	{
		return false;
	}
	
	if(!spiritsaway::property::has_default_value<decltype(m_e)>()(m_e))
	{
		return false;
	}
	
	if(!spiritsaway::property::has_default_value<decltype(m_f)>()(m_f))
	{
		return false;
	}
	if(!m_g.has_default_value())
	{
		return false;
	}
	
	return true;
}


