
#ifndef __meta_parse__

template <> 
class prop_record_proxy<spiritsaway::test::simple_bag_item>
	
{
	spiritsaway::test::simple_bag_item& m_simple_bag_item_data;
	item_msg_queue m_queue;
	const property_flags m_flag;
public:

public:
	prop_record_proxy(spiritsaway::test::simple_bag_item& data, msg_queue_base& msg_queue,
		const property_record_offset& offset, const property_flags& flag, std::uint32_t data_idx)
		: m_queue(msg_queue, offset, data_idx)
		, m_simple_bag_item_data(data)
		, m_flag(flag)
	{

	}
	

	




	const spiritsaway::test::simple_bag_item& data() const
	{
		return m_simple_bag_item_data;
	}

	prop_record_proxy<decltype(m_simple_bag_item_data.m_a)> a()
	{
		property_record_offset empty_offset;
		return prop_record_proxy<decltype(m_simple_bag_item_data.m_a)>(m_simple_bag_item_data.m_a, m_queue, empty_offset.merge(spiritsaway::test::simple_bag_item::index_for_a), m_flag.merge(property_flags{ spiritsaway::test::simple_bag_item::flag_for_a}));
	}
	prop_record_proxy<decltype(m_simple_bag_item_data.m_b)> b()
	{
		property_record_offset empty_offset;
		return prop_record_proxy<decltype(m_simple_bag_item_data.m_b)>(m_simple_bag_item_data.m_b, m_queue, empty_offset.merge(spiritsaway::test::simple_bag_item::index_for_b), m_flag.merge(property_flags{ spiritsaway::test::simple_bag_item::flag_for_b}));
	}



	void update_fields(const json& other_json)
	{
		spiritsaway::test::simple_bag_item new_simple_bag_item_data;
		if(!serialize::decode(other_json, new_simple_bag_item_data))
		{
			return;
		}
		std::vector<std::uint8_t> related_field_indexes;
		related_field_indexes.reserve(8);
		m_simple_bag_item_data.update_fields(new_simple_bag_item_data, other_json, related_field_indexes);
		json::array_t temp_encode_array(2);
		temp_encode_array[0] = related_field_indexes;
		property_record_offset empty_offset;
		for (auto one_need_flag : m_queue.m_need_flags)
		{
			if (one_need_flag.include_by(m_flag))
			{
				temp_encode_array[1] = new_simple_bag_item_data.encode_with_flag(one_need_flag, m_queue.m_encode_ignore_default, m_queue.m_encode_with_array);

				m_queue.add_for_flag(empty_offset.merge(spiritsaway::test::simple_bag_item::index_end_for_simple_bag_item), property_cmd::update_fields, one_need_flag, m_flag, json(temp_encode_array));
			}
		}
	}
};
#endif