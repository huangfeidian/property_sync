namespace spiritsaway::test
{


bool simple_slot_item::replay_mutate_msg(spiritsaway::property::property_replay_offset offset, spiritsaway::property::property_cmd cmd, const json& data)
{
	using std::swap;
	auto split_result = offset.split();
	auto field_index = split_result.second;
	auto remain_offset = split_result.first;
	switch(field_index)
	{
		case index_for_a:
		{
			auto temp_proxy = spiritsaway::property::make_replay_proxy(m_a);
			return temp_proxy.replay(remain_offset, cmd, data);
		}
		case index_for_b:
		{
			auto temp_proxy = spiritsaway::property::make_replay_proxy(m_b);
			return temp_proxy.replay(remain_offset, cmd, data);
		}
		
		case index_end_for_simple_slot_item:
		{
			if(cmd == spiritsaway::property::property_cmd::update_fields)
			{
				std::vector<std::uint8_t> related_fields;
				std::vector<std::pair<std::uint8_t, json>> field_values;
				if(!serialize::decode_multi(data, related_fields, field_values))
				{
					return false;
				}
				clear_fields(related_fields);
				return set_fields(field_values);
			}
			else
			{
				return false;
			}
		}
		default:
			return spiritsaway::property::property_slot_item<int>::replay_mutate_msg(offset, cmd, data);
		
	}
}

bool simple_slot_item::operator==(const simple_slot_item& other) const
{
	if(!spiritsaway::property::property_slot_item<int>::operator==(other))
	{
		return false;
	}
	if(m_a != other.m_a)
	{
		return false;
	}
	if(m_b != other.m_b)
	{
		return false;
	}
	return true;
}
bool simple_slot_item::operator!=(const simple_slot_item& other) const
{
	return !(operator==(other));
}


json simple_slot_item::encode() const
{
	json result = spiritsaway::property::property_slot_item<int>::encode();
	
	
	if(!spiritsaway::property::has_default_value<decltype(m_a)>()(m_a))
	{
		result["a"] = spiritsaway::serialize::encode(m_a);
	}
	
	if(!spiritsaway::property::has_default_value<decltype(m_b)>()(m_b))
	{
		result["b"] = spiritsaway::serialize::encode(m_b);
	}
	return result;
}
void simple_slot_item::encode_with_flag(const spiritsaway::property::property_flags flag, bool ignore_default, json::array_t& result) const
{
	spiritsaway::property::property_slot_item<int>::encode_with_flag(flag, ignore_default, result);

	if((flag_for_a & flag.value) == flag.value)
	{
		
		if(!ignore_default ||!spiritsaway::property::has_default_value<decltype(m_a)>()(m_a))
		{
			result.push_back(spiritsaway::serialize::encode(std::make_pair(index_for_a, m_a)));
		}
	}
	if((flag_for_b & flag.value) == flag.value)
	{
		
		if(!ignore_default ||!spiritsaway::property::has_default_value<decltype(m_b)>()(m_b))
		{
			result.push_back(spiritsaway::serialize::encode(std::make_pair(index_for_b, m_b)));
		}
	}
	return;
}

void simple_slot_item::encode_with_flag(const spiritsaway::property::property_flags flag, bool ignore_default, json::object_t& result) const
{
	spiritsaway::property::property_slot_item<int>::encode_with_flag(flag, ignore_default, result);

	if((flag_for_a & flag.value) == flag.value)
	{
		
		if(!ignore_default ||!spiritsaway::property::has_default_value<decltype(m_a)>()(m_a))
		{
			result["a"] = spiritsaway::serialize::encode(m_a);
		}
	}
	if((flag_for_b & flag.value) == flag.value)
	{
		
		if(!ignore_default ||!spiritsaway::property::has_default_value<decltype(m_b)>()(m_b))
		{
			result["b"] = spiritsaway::serialize::encode(m_b);
		}
	}
	return;
}
json simple_slot_item::encode_with_flag(const spiritsaway::property::property_flags flag, bool ignore_default, bool replace_key_by_index) const
{
	if (replace_key_by_index)
	{
		json::array_t result;
		encode_with_flag(flag, ignore_default, result);
		return result;
	}
	else
	{
		json::object_t result;
		encode_with_flag(flag, ignore_default, result);
		return result;
	}
}

bool simple_slot_item::decode(const std::vector<std::pair<std::uint8_t, json>>& data, std::uint32_t& next_idx)
{
	if(!spiritsaway::property::property_slot_item<int>::decode(data, next_idx))
	{
		return false;
	}
	while(next_idx < data.size())
	{
		const auto& one_item = data[next_idx];
		if(one_item.first >= index_end_for_simple_slot_item)
		{
			return true;
		}
		if(one_item.first < index_begin_for_simple_slot_item)
		{
			return false;
		}
		switch(one_item.first)
		{
			case index_for_a:
			{
				if(!spiritsaway::serialize::decode(one_item.second, m_a))
				{
					return false;
				}
				break;
			}
			case index_for_b:
			{
				if(!spiritsaway::serialize::decode(one_item.second, m_b))
				{
					return false;
				}
				break;
			}
			default:
				return false;
		}
		next_idx++;
	}
	return true;
}

bool simple_slot_item::decode(const json::object_t& data)
{
	if(!spiritsaway::property::property_slot_item<int>::decode(data))
	{
		return false;
	}
	decltype(data.end()) iter;
	iter = data.find("a");
	if(iter != data.end())
	{
		if(!spiritsaway::serialize::decode(iter->second, m_a))
		{
			return false;
		}
	}
	
	iter = data.find("b");
	if(iter != data.end())
	{
		if(!spiritsaway::serialize::decode(iter->second, m_b))
		{
			return false;
		}
	}
	
	return true;
}

bool simple_slot_item::decode(const json& data)
{
	if(data.is_object())
	{
		json::object_t obj_data = data.get<json::object_t>();
		return decode(obj_data);
	}
	else if(data.is_array())
	{
		std::vector<std::pair<std::uint8_t, json>> array_data;
		if(!spiritsaway::serialize::decode(data, array_data))
		{
			return false;
		}
		std::uint32_t next_idx = 0;
		if(!decode(array_data, next_idx))
		{
			return false;
		}
		if(next_idx != array_data.size())
		{
			return false;
		}
		return true;
	}
	return false;
	
}

bool simple_slot_item::has_default_value() const
{
	if(!spiritsaway::property::property_slot_item<int>::has_default_value())
	{
		return false;
	}
	
	if(!spiritsaway::property::has_default_value<decltype(m_a)>()(m_a))
	{
		return false;
	}
	
	if(!spiritsaway::property::has_default_value<decltype(m_b)>()(m_b))
	{
		return false;
	}
	return true;
}
void simple_slot_item::update_fields(const simple_slot_item& other, const json& other_json, std::vector<std::uint8_t>& field_indexes)
{
	spiritsaway::property::property_slot_item<int>::update_fields(other, other_json, field_indexes);
	auto temp_iter_for_a = other_json.find("a");
	if(temp_iter_for_a != other_json.end())
	{
		m_a = other.m_a;
		field_indexes.push_back(index_for_a);
	}
	auto temp_iter_for_b = other_json.find("b");
	if(temp_iter_for_b != other_json.end())
	{
		m_b = other.m_b;
		field_indexes.push_back(index_for_b);
	}
}

void simple_slot_item::clear_fields(const std::vector<std::uint8_t>& related_indexes)
{
	spiritsaway::property::property_slot_item<int>::clear_fields(related_indexes);
	for(auto one_idx: related_indexes)
	{
		switch(one_idx)
		{
		case index_for_a:
		{
			m_a = {};
			break;
		}
		case index_for_b:
		{
			m_b = {};
			break;
		}
		default:
			break;
		}
	}
}

bool simple_slot_item::set_fields(const std::vector<std::pair<std::uint8_t, json>>& field_values)
{
	if(!spiritsaway::property::property_slot_item<int>::set_fields(field_values))
	{
		return false;
	}
	for(auto one_idx_pair: field_values)
	{
		switch(one_idx_pair.first)
		{
		case index_for_a:
		{
			if(!serialize::decode(one_idx_pair.second, m_a))
			{
				return false;
			}
			break;
		}
		case index_for_b:
		{
			if(!serialize::decode(one_idx_pair.second, m_b))
			{
				return false;
			}
			break;
		}
		default:
			break;
		}
	}
	return true;
	
}

}